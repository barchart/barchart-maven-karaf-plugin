diff --git a/src/it/test-feature-range/.classpath b/src/it/test-feature-range/.classpath
new file mode 100644
index 0000000..bd36355
--- /dev/null
+++ b/src/it/test-feature-range/.classpath
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
+		<attributes>
+			<attribute name="maven.pomderived" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="output" path="target/classes"/>
+</classpath>
diff --git a/src/it/test-feature-range/.project b/src/it/test-feature-range/.project
new file mode 100644
index 0000000..c0c7b19
--- /dev/null
+++ b/src/it/test-feature-range/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>test-feature-range</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.m2e.core.maven2Builder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.m2e.core.maven2Nature</nature>
+	</natures>
+</projectDescription>
diff --git a/src/it/test-feature-range/.settings/org.eclipse.core.resources.prefs b/src/it/test-feature-range/.settings/org.eclipse.core.resources.prefs
new file mode 100644
index 0000000..99f26c0
--- /dev/null
+++ b/src/it/test-feature-range/.settings/org.eclipse.core.resources.prefs
@@ -0,0 +1,2 @@
+eclipse.preferences.version=1
+encoding/<project>=UTF-8
diff --git a/src/it/test-feature-range/.settings/org.eclipse.jdt.core.prefs b/src/it/test-feature-range/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..abec6ca
--- /dev/null
+++ b/src/it/test-feature-range/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,5 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.5
+org.eclipse.jdt.core.compiler.compliance=1.5
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
+org.eclipse.jdt.core.compiler.source=1.5
diff --git a/src/it/test-feature-range/.settings/org.eclipse.m2e.core.prefs b/src/it/test-feature-range/.settings/org.eclipse.m2e.core.prefs
new file mode 100644
index 0000000..f897a7f
--- /dev/null
+++ b/src/it/test-feature-range/.settings/org.eclipse.m2e.core.prefs
@@ -0,0 +1,4 @@
+activeProfiles=
+eclipse.preferences.version=1
+resolveWorkspaceProjects=true
+version=1
diff --git a/src/it/test-feature-range/.settings/org.eclipse.pde.core.prefs b/src/it/test-feature-range/.settings/org.eclipse.pde.core.prefs
new file mode 100644
index 0000000..ba582c2
--- /dev/null
+++ b/src/it/test-feature-range/.settings/org.eclipse.pde.core.prefs
@@ -0,0 +1,2 @@
+BUNDLE_ROOT_PATH=target/classes
+eclipse.preferences.version=1
diff --git a/src/it/test-feature-range/_build_/maven-install-debug.ant b/src/it/test-feature-range/_build_/maven-install-debug.ant
new file mode 100644
index 0000000..b8dfc24
--- /dev/null
+++ b/src/it/test-feature-range/_build_/maven-install-debug.ant
@@ -0,0 +1,26 @@
+<project default="maven" basedir="./..">
+
+	<target name="maven">
+
+		<echo message="basedir : ${basedir}" />
+
+		<!-- note: mvn executable must be present on o/s path -->
+		<condition property="executable" value="mvn.bat">
+			<os family="windows" />
+		</condition>
+		<condition property="executable" value="mvn">
+			<os family="unix" />
+		</condition>
+
+		<exec executable="${executable}">
+
+			<arg value="clean" />
+			<arg value="install" />
+
+			<arg value="--debug" />
+
+		</exec>
+
+	</target>
+
+</project>
diff --git a/src/it/test-feature-range/_build_/maven-install.ant b/src/it/test-feature-range/_build_/maven-install.ant
new file mode 100644
index 0000000..63c4836
--- /dev/null
+++ b/src/it/test-feature-range/_build_/maven-install.ant
@@ -0,0 +1,26 @@
+<project default="maven" basedir="./..">
+
+	<target name="maven">
+
+		<echo message="basedir : ${basedir}" />
+
+		<!-- note: mvn executable must be present on o/s path -->
+		<condition property="executable" value="mvn.bat">
+			<os family="windows" />
+		</condition>
+		<condition property="executable" value="mvn">
+			<os family="unix" />
+		</condition>
+
+		<exec executable="${executable}">
+
+			<arg value="clean" />
+			<arg value="install" />
+
+			<arg value="--update-snapshots" />
+
+		</exec>
+
+	</target>
+
+</project>
diff --git a/src/it/test-feature-range/control.xml b/src/it/test-feature-range/control.xml
new file mode 100644
index 0000000..06139fe
--- /dev/null
+++ b/src/it/test-feature-range/control.xml
@@ -0,0 +1,21 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<!--
+  ~ Licensed to the Apache Software Foundation (ASF) under one
+  ~ or more contributor license agreements.  See the NOTICE file
+  ~ distributed with this work for additional information
+  ~ regarding copyright ownership.  The ASF licenses this file
+  ~ to you under the Apache License, Version 2.0 (the
+  ~ "License"); you may not use this file except in compliance
+  ~ with the License.  You may obtain a copy of the License at
+  ~
+  ~   http://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing,
+  ~ software distributed under the License is distributed on an
+  ~ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+  ~ KIND, either express or implied.  See the License for the
+  ~ specific language governing permissions and limitations
+  ~ under the License.
+  -->
+
+<features xmlns="http://karaf.apache.org/xmlns/features/v1.2.0" name="test-basic-generation"/>
diff --git a/src/it/test-feature-range/pom.xml b/src/it/test-feature-range/pom.xml
new file mode 100644
index 0000000..38f90ef
--- /dev/null
+++ b/src/it/test-feature-range/pom.xml
@@ -0,0 +1,104 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- ~ Licensed to the Apache Software Foundation (ASF) under one ~ or more 
+	contributor license agreements. See the NOTICE file ~ distributed with this 
+	work for additional information ~ regarding copyright ownership. The ASF 
+	licenses this file ~ to you under the Apache License, Version 2.0 (the ~ 
+	"License"); you may not use this file except in compliance ~ with the License. 
+	You may obtain a copy of the License at ~ ~ http://www.apache.org/licenses/LICENSE-2.0 
+	~ ~ Unless required by applicable law or agreed to in writing, ~ software 
+	distributed under the License is distributed on an ~ "AS IS" BASIS, WITHOUT 
+	WARRANTIES OR CONDITIONS OF ANY ~ KIND, either express or implied. See the 
+	License for the ~ specific language governing permissions and limitations 
+	~ under the License. -->
+<project
+	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"
+	xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
+	<modelVersion>4.0.0</modelVersion>
+
+	<parent>
+		<groupId>com.barchart.base</groupId>
+		<artifactId>barchart-archon</artifactId>
+		<version>2.5.6</version>
+		<relativePath />
+	</parent>
+
+	<groupId>test</groupId>
+	<artifactId>test-feature-range</artifactId>
+	<version>1.0-SNAPSHOT</version>
+	<packaging>pom</packaging>
+
+	<properties>
+		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+	</properties>
+
+	<dependencies>
+
+		<!-- API Consumer bundle dependency. -->
+		<dependency>
+			<groupId>com.barchart.version.tester</groupId>
+			<artifactId>tester-one-api-consumer</artifactId>
+			<version>[3,4)</version>
+		</dependency>
+
+		<!-- API Provider bundle dependency. -->
+		<dependency>
+			<groupId>com.barchart.version.tester</groupId>
+			<artifactId>tester-one-api-provider</artifactId>
+			<version>[5,6)</version>
+		</dependency>
+
+	</dependencies>
+
+	<build>
+		<plugins>
+
+			<plugin>
+				<groupId>org.apache.karaf.tooling</groupId>
+				<artifactId>karaf-maven-plugin</artifactId>
+				<version>3.0.0-build003-SNAPSHOT</version>
+				<!-- <version>@project.version@</version> -->
+				<extensions>true</extensions>
+				<executions>
+					<execution>
+						<goals>
+							<goal>features-generate-semantic</goal>
+						</goals>
+					</execution>
+				</executions>
+			</plugin>
+
+		</plugins>
+		<pluginManagement>
+			<plugins>
+				<!--This plugin's configuration is used to store Eclipse m2e settings 
+					only. It has no influence on the Maven build itself. -->
+				<plugin>
+					<groupId>org.eclipse.m2e</groupId>
+					<artifactId>lifecycle-mapping</artifactId>
+					<version>1.0.0</version>
+					<configuration>
+						<lifecycleMappingMetadata>
+							<pluginExecutions>
+								<pluginExecution>
+									<pluginExecutionFilter>
+										<groupId>org.apache.karaf.tooling
+										</groupId>
+										<artifactId>karaf-maven-plugin</artifactId>
+										<versionRange>[0,)</versionRange>
+										<goals>
+											<goal>features-generate-descriptor</goal>
+											<goal>features-generate-semantic</goal>
+										</goals>
+									</pluginExecutionFilter>
+									<action>
+										<ignore />
+									</action>
+								</pluginExecution>
+							</pluginExecutions>
+						</lifecycleMappingMetadata>
+					</configuration>
+				</plugin>
+			</plugins>
+		</pluginManagement>
+	</build>
+</project>
diff --git a/src/it/test-feature-range/target/feature/feature.xml b/src/it/test-feature-range/target/feature/feature.xml
new file mode 100644
index 0000000..8e0c672
--- /dev/null
+++ b/src/it/test-feature-range/target/feature/feature.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<features xmlns="http://karaf.apache.org/xmlns/features/v1.2.0" name="test-feature-range">
+    <feature name="test-feature-range" version="1.0-SNAPSHOT" description="test-feature-range">
+        <details>test-feature-range</details>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.0.0</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.0.1</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.1.1-SNAPSHOT</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.0.4-SNAPSHOT</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.1.0</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.0.2</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.0.3</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.1.1-SNAPSHOT</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.0.3-SNAPSHOT</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-consumer/3.0.1</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.0.1</bundle>
+        <bundle>wrap:mvn:test/test-feature-range/1.0-SNAPSHOT/pom</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-consumer/3.0.2</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.1.0</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api/2.0.2</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-consumer/3.0.3</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-provider/5.0.0</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-consumer/3.0.0</bundle>
+        <bundle>mvn:com.barchart.version.tester/tester-one-api-consumer/3.0.4-SNAPSHOT</bundle>
+    </feature>
+</features>
diff --git a/src/it/test-feature-range/verify.bsh b/src/it/test-feature-range/verify.bsh
new file mode 100644
index 0000000..4608109
--- /dev/null
+++ b/src/it/test-feature-range/verify.bsh
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+// FIXME plug
+return true;
+
+import org.custommonkey.xmlunit.*;
+import java.io.*;
+import java.lang.*;
+
+Reader r = new FileReader(new File(basedir, "control.xml"));
+
+// load the features file pushed to the repository
+File generated = new File( localRepositoryPath, "test/test-feature-range/1.0-SNAPSHOT/test-basic-generation-1.0-SNAPSHOT-features.xml" );
+if (generated.exists()) {
+    try {
+        XMLAssert.assertXMLEqual(r, new FileReader(generated));
+        return true;
+    } catch (Throwable ignored) { }
+}
+
+return false;
diff --git a/src/main/java/org/apache/karaf/tooling/ap/GenerateSemanticMojo.java b/src/main/java/org/apache/karaf/tooling/ap/GenerateSemanticMojo.java
new file mode 100644
index 0000000..01c0905
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/GenerateSemanticMojo.java
@@ -0,0 +1,174 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.karaf.tooling.ap;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.karaf.tooling.ap.xform.NearestTransformer;
+import org.apache.karaf.tooling.ap.xform.SemanticTransformer;
+import org.apache.karaf.tooling.features.GenerateDescriptorMojo;
+import org.apache.maven.RepositoryUtils;
+import org.apache.maven.project.MavenProject;
+import org.codehaus.plexus.logging.Logger;
+import org.sonatype.aether.RepositorySystem;
+import org.sonatype.aether.RepositorySystemSession;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.collection.CollectRequest;
+import org.sonatype.aether.collection.CollectResult;
+import org.sonatype.aether.collection.DependencySelector;
+import org.sonatype.aether.graph.Dependency;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.impl.internal.DefaultRepositorySystem;
+import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.resolution.DependencyRequest;
+import org.sonatype.aether.resolution.DependencyResult;
+import org.sonatype.aether.util.DefaultRepositorySystemSession;
+import org.sonatype.aether.util.graph.PreorderNodeListGenerator;
+import org.sonatype.aether.util.graph.selector.AndDependencySelector;
+import org.sonatype.aether.util.graph.selector.ExclusionDependencySelector;
+import org.sonatype.aether.util.graph.selector.OptionalDependencySelector;
+import org.sonatype.aether.util.graph.selector.ScopeDependencySelector;
+import org.sonatype.aether.util.graph.transformer.ChainedDependencyGraphTransformer;
+import org.sonatype.aether.util.graph.transformer.ConflictIdSorter;
+import org.sonatype.aether.util.graph.transformer.ConflictMarker;
+import org.sonatype.aether.util.graph.transformer.NearestVersionConflictResolver;
+import org.sonatype.aether.util.graph.transformer.NoopDependencyGraphTransformer;
+
+/**
+ * Generates the semantic features XML file for packaging=pom
+ * 
+ * @goal features-generate-semantic
+ * @phase compile
+ * @requiresDependencyResolution runtime
+ * @inheritByDefault true
+ * @description TODO
+ * 
+ * @author Andrei Pozolotin
+ */
+public class GenerateSemanticMojo extends GenerateDescriptorMojo {
+
+	/**
+	 * Dependency scope to include. Default include: compile.
+	 * 
+	 * @parameter
+	 */
+	protected Set<String> scopeIncluded;
+	{
+		scopeIncluded = new HashSet<String>();
+		scopeIncluded.add("compile");
+	}
+
+	/**
+	 * Dependency scope to exclude. Default exclude: runtime, provided, system,
+	 * test.
+	 * 
+	 * @parameter
+	 */
+	protected Set<String> scopeExcluded;
+	{
+		scopeExcluded = new HashSet<String>();
+		scopeExcluded.add("runtime");
+		scopeExcluded.add("provided");
+		scopeExcluded.add("system");
+		scopeExcluded.add("test");
+	}
+
+	/**
+	 */
+	public static Map<Artifact, String> prepare(MojoContext context)
+			throws Exception {
+
+		final Artifact artifact = RepositoryUtils.toArtifact(context.project
+				.getArtifact());
+
+		final Dependency dependencyRoot = new Dependency(artifact, "compile");
+
+		final CollectRequest collectRequest = new CollectRequest(
+				dependencyRoot, context.projectRepos);
+
+		final DependencySelector selector = new AndDependencySelector(//
+				new OptionalDependencySelector(), //
+				new ScopeDependencySelector(context.scopeIncluded,
+						context.scopeExcluded), //
+				new ExclusionDependencySelector());
+
+		final DefaultRepositorySystemSession localSession = new DefaultRepositorySystemSession(
+				context.session);
+
+		localSession.setDependencySelector(selector);
+
+		ConflictMarker marker = new ConflictMarker();
+		ConflictIdSorter sorter = new ConflictIdSorter();
+		NearestTransformer nearest = new NearestTransformer();
+		ChainedDependencyGraphTransformer transformer = new ChainedDependencyGraphTransformer(
+				marker, sorter, nearest);
+
+		localSession.setDependencyGraphTransformer(transformer);
+
+		final CollectResult collectResult = context.system.collectDependencies(
+				localSession, collectRequest);
+
+		final DependencyNode collectNode = collectResult.getRoot();
+
+		final DependencyRequest dependencyRequest = new DependencyRequest(
+				collectNode, null);
+
+		final DependencyResult resolveResult = context.system
+				.resolveDependencies(localSession, dependencyRequest);
+
+		final DependencyNode resolvedNode = resolveResult.getRoot();
+
+		final PreorderNodeListGenerator generator = new PreorderNodeListGenerator();
+
+		resolvedNode.accept(generator);
+
+		final List<Dependency> dependencyList = generator.getDependencies(true);
+
+		// [dependency:scope]
+		final Map<Artifact, String> dependencyMap = new HashMap<Artifact, String>();
+
+		for (Dependency dependency : dependencyList) {
+
+			context.logger.info("### dependency : " + dependency);
+
+			dependencyMap.put(dependency.getArtifact(), dependency.getScope());
+
+		}
+
+		return dependencyMap;
+
+	}
+
+	@Override
+	protected void prepare() throws Exception {
+
+		MojoContext context = new MojoContext(getLogger(), project,
+				scopeIncluded, scopeExcluded, repoSystem, repoSession,
+				projectRepos);
+
+		this.localDependencies = prepare(context);
+
+		this.treeListing = "not available";
+
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/MojoContext.java b/src/main/java/org/apache/karaf/tooling/ap/MojoContext.java
new file mode 100644
index 0000000..3bdcab0
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/MojoContext.java
@@ -0,0 +1,42 @@
+package org.apache.karaf.tooling.ap;
+
+import java.util.List;
+import java.util.Set;
+
+import org.apache.maven.project.MavenProject;
+import org.codehaus.plexus.logging.Logger;
+import org.sonatype.aether.RepositorySystem;
+import org.sonatype.aether.RepositorySystemSession;
+import org.sonatype.aether.repository.RemoteRepository;
+
+public class MojoContext {
+
+	public final Logger logger;
+	public final MavenProject project;
+	public final Set<String> scopeIncluded;
+	public final Set<String> scopeExcluded;
+	public final RepositorySystem system;
+	public final RepositorySystemSession session;
+	public final List<RemoteRepository> projectRepos;
+
+	public MojoContext(//
+			Logger logger, //
+			MavenProject project, //
+			Set<String> scopeIncluded, //
+			Set<String> scopeExcluded, //
+			RepositorySystem system, //
+			RepositorySystemSession session, //
+			List<RemoteRepository> projectRepos //
+	) {
+
+		this.logger = logger;
+		this.project = project;
+		this.scopeIncluded = scopeIncluded;
+		this.scopeExcluded = scopeExcluded;
+		this.system = system;
+		this.session = session;
+		this.projectRepos = projectRepos;
+
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/ReflectUtil.java b/src/main/java/org/apache/karaf/tooling/ap/ReflectUtil.java
new file mode 100644
index 0000000..f0a5bbe
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/ReflectUtil.java
@@ -0,0 +1,18 @@
+package org.apache.karaf.tooling.ap;
+
+import java.lang.reflect.Field;
+
+public class ReflectUtil {
+
+	@SuppressWarnings("unchecked")
+	public static <T> T readField(Object instance, String name) {
+		try {
+			Field field = instance.getClass().getDeclaredField(name);
+			field.setAccessible(true);
+			return (T) field.get(instance);
+		} catch (Throwable e) {
+			throw new IllegalStateException("Failed to read field.", e);
+		}
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRange.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRange.java
new file mode 100644
index 0000000..01f00aa
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRange.java
@@ -0,0 +1,111 @@
+package org.apache.karaf.tooling.ap.range;
+
+import org.sonatype.aether.version.Version;
+
+/**
+ * A range of versions.
+ */
+public interface SemanticRange {
+
+	/**
+	 * Determines whether the specified version is contained within this range.
+	 * 
+	 * @param version
+	 *            The version to test, must not be {@code null}.
+	 * @return {@code true} if this range contains the specified version,
+	 *         {@code false} otherwise.
+	 */
+	boolean containsVersion(Version version);
+
+	/**
+	 * Gets a lower bound (if any) for this range. If existent, this range does
+	 * not contain any version smaller than its lower bound. Note that complex
+	 * version ranges might exclude some versions even within their bounds.
+	 * 
+	 * @return A lower bound for this range or {@code null} is there is none.
+	 */
+	Bound getLowerBound();
+
+	/**
+	 * Gets an upper bound (if any) for this range. If existent, this range does
+	 * not contain any version greater than its upper bound. Note that complex
+	 * version ranges might exclude some versions even within their bounds.
+	 * 
+	 * @return An upper bound for this range or {@code null} is there is none.
+	 */
+	Bound getUpperBound();
+
+	/**
+	 * A bound of a version range.
+	 */
+	static final class Bound {
+
+		private final Version version;
+
+		private final boolean inclusive;
+
+		/**
+		 * Creates a new bound with the specified properties.
+		 * 
+		 * @param version
+		 *            The bounding version, must not be {@code null}.
+		 * @param inclusive
+		 *            A flag whether the specified version is included in the
+		 *            range or not.
+		 */
+		public Bound(Version version, boolean inclusive) {
+			if (version == null) {
+				throw new IllegalArgumentException("version missing");
+			}
+			this.version = version;
+			this.inclusive = inclusive;
+		}
+
+		/**
+		 * Gets the bounding version.
+		 * 
+		 * @return The bounding version, never {@code null}.
+		 */
+		public Version getVersion() {
+			return version;
+		}
+
+		/**
+		 * Indicates whether the bounding version is included in the range or
+		 * not.
+		 * 
+		 * @return {@code true} if the bounding version is included in the
+		 *         range, {@code false} if not.
+		 */
+		public boolean isInclusive() {
+			return inclusive;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj == this) {
+				return true;
+			} else if (obj == null || !getClass().equals(obj.getClass())) {
+				return false;
+			}
+
+			Bound that = (Bound) obj;
+			return inclusive == that.inclusive && version.equals(that.version);
+		}
+
+		@Override
+		public int hashCode() {
+			int hash = 17;
+			hash = hash * 31 + version.hashCode();
+			hash = hash * 31 + (inclusive ? 1 : 0);
+			return hash;
+		}
+
+		@Override
+		public String toString() {
+			return String.valueOf(version);
+		}
+
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeBase.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeBase.java
new file mode 100644
index 0000000..eb68c1a
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeBase.java
@@ -0,0 +1,14 @@
+package org.apache.karaf.tooling.ap.range;
+
+public abstract class SemanticRangeBase implements SemanticRange {
+
+	public boolean equals(Object other) {
+		if (other instanceof SemanticRange) {
+			SemanticRange that = (SemanticRange) other;
+			return this.getLowerBound().equals(that.getLowerBound())
+					&& this.getUpperBound().equals(that.getUpperBound());
+		}
+		return false;
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeFactory.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeFactory.java
new file mode 100644
index 0000000..26fd0d2
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeFactory.java
@@ -0,0 +1,43 @@
+package org.apache.karaf.tooling.ap.range;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionConstraint;
+import org.sonatype.aether.version.VersionRange;
+
+public class SemanticRangeFactory {
+
+	public static SemanticRange from(DependencyNode node) {
+
+		VersionConstraint constraint = node.getVersionConstraint();
+
+		VersionType versionType = VersionType.form(constraint);
+
+		switch (versionType) {
+
+		case VALUE:
+			Version version = constraint.getVersion();
+			return new SemanticRangePoint(version);
+
+		case RANGE:
+			Collection<VersionRange> rangeList = constraint.getRanges();
+			Iterator<VersionRange> iterator = rangeList.iterator();
+			VersionRange range = iterator.next();
+			if (iterator.hasNext()) {
+				throw new IllegalStateException("Unexpected multiple ranges = "
+						+ rangeList);
+			}
+			return new SemanticRangeSpan(range);
+
+		default:
+			throw new IllegalStateException("Wrong version type = "
+					+ versionType);
+
+		}
+
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeList.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeList.java
new file mode 100644
index 0000000..43643cc
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeList.java
@@ -0,0 +1,8 @@
+package org.apache.karaf.tooling.ap.range;
+
+import java.util.concurrent.CopyOnWriteArrayList;
+
+@SuppressWarnings("serial")
+public class SemanticRangeList extends CopyOnWriteArrayList<SemanticRange>{
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangePoint.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangePoint.java
new file mode 100644
index 0000000..61237dc
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangePoint.java
@@ -0,0 +1,33 @@
+package org.apache.karaf.tooling.ap.range;
+
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionRange;
+
+public class SemanticRangePoint extends SemanticRangeBase {
+
+	private final Version version;
+
+	public SemanticRangePoint(Version version) {
+		this.version = version;
+	}
+
+	@Override
+	public boolean containsVersion(Version version) {
+		return this.version.equals(version);
+	}
+
+	@Override
+	public Bound getLowerBound() {
+		return new Bound(version, true);
+	}
+
+	@Override
+	public Bound getUpperBound() {
+		return new Bound(version, true);
+	}
+
+	public String toString() {
+		return "[" + version + "," + version + "]";
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeSpan.java b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeSpan.java
new file mode 100644
index 0000000..f03ac11
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/SemanticRangeSpan.java
@@ -0,0 +1,38 @@
+package org.apache.karaf.tooling.ap.range;
+
+import org.apache.karaf.tooling.ap.ReflectUtil;
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionRange;
+
+public class SemanticRangeSpan extends SemanticRangeBase {
+
+	private final VersionRange range;
+
+	public SemanticRangeSpan(VersionRange range) {
+		this.range = range;
+	}
+
+	@Override
+	public boolean containsVersion(Version version) {
+		return range.containsVersion(version);
+	}
+
+	@Override
+	public Bound getLowerBound() {
+		Version version = ReflectUtil.readField(range, "lowerBound");
+		boolean inclusive = ReflectUtil.readField(range, "lowerBoundInclusive");
+		return new Bound(version, inclusive);
+	}
+
+	@Override
+	public Bound getUpperBound() {
+		Version version = ReflectUtil.readField(range, "upperBound");
+		boolean inclusive = ReflectUtil.readField(range, "upperBoundInclusive");
+		return new Bound(version, inclusive);
+	}
+
+	public String toString() {
+		return range.toString();
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/range/VersionType.java b/src/main/java/org/apache/karaf/tooling/ap/range/VersionType.java
new file mode 100644
index 0000000..8b449a2
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/range/VersionType.java
@@ -0,0 +1,33 @@
+package org.apache.karaf.tooling.ap.range;
+
+import org.sonatype.aether.version.VersionConstraint;
+
+public enum VersionType {
+
+	/***/
+	RANGE, //
+
+	/***/
+	VALUE, //
+
+	/***/
+	WRONG, //
+
+	;
+
+	public static VersionType form(final VersionConstraint constraint) {
+		if (constraint == null) {
+			return WRONG;
+		}
+		boolean hasRange = !constraint.getRanges().isEmpty();
+		boolean hasValue = constraint.getVersion() != null;
+		if (hasRange && !hasValue) {
+			return RANGE;
+		}
+		if (!hasRange && hasValue) {
+			return VALUE;
+		}
+		return WRONG;
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/xform/BaseTransformer.java b/src/main/java/org/apache/karaf/tooling/ap/xform/BaseTransformer.java
new file mode 100644
index 0000000..c4a1015
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/xform/BaseTransformer.java
@@ -0,0 +1,63 @@
+package org.apache.karaf.tooling.ap.xform;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.karaf.tooling.ap.range.SemanticRangeFactory;
+import org.apache.karaf.tooling.ap.range.SemanticRangeList;
+import org.apache.karaf.tooling.ap.range.SemanticRange;
+import org.apache.karaf.tooling.ap.range.VersionType;
+import org.sonatype.aether.RepositoryException;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.collection.DependencyGraphTransformationContext;
+import org.sonatype.aether.collection.DependencyGraphTransformer;
+import org.sonatype.aether.graph.Dependency;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.util.graph.transformer.TransformationContextKeys;
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionConstraint;
+
+/**
+ * "Object" of "Conflict ID" is an artifact key, that is, artifact w/o version.
+ * <p>
+ * equality == group:artifact:classifier:extensions
+ * <p>
+ * identity == unique instance
+ * <p>
+ * Conflict list and map must be produced by previous transformers.
+ * 
+ * @author Andrei Pozolotin
+ */
+public abstract class BaseTransformer implements DependencyGraphTransformer {
+
+	/**
+	 * Topologically sorted artifact keys.
+	 */
+	@SuppressWarnings("unchecked")
+	public List<Object> conflictList(
+			DependencyGraphTransformationContext context) {
+		final List<Object> conflictList = (List<Object>) context
+				.get(TransformationContextKeys.SORTED_CONFLICT_IDS);
+		return conflictList;
+	}
+
+	/**
+	 * Mapping from versioned artifact into artifact keys.
+	 */
+	@SuppressWarnings("unchecked")
+	public Map<DependencyNode, Object> conflictMap(
+			DependencyGraphTransformationContext context) {
+		final Map<DependencyNode, Object> conflictMap = (Map<DependencyNode, Object>) context
+				.get(TransformationContextKeys.CONFLICT_IDS);
+		return conflictMap;
+	}
+
+	protected void log(String text) {
+		System.err.println(text);
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/xform/NearestTransformer.java b/src/main/java/org/apache/karaf/tooling/ap/xform/NearestTransformer.java
new file mode 100644
index 0000000..899daaf
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/xform/NearestTransformer.java
@@ -0,0 +1,267 @@
+package org.apache.karaf.tooling.ap.xform;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+
+import org.sonatype.aether.RepositoryException;
+import org.sonatype.aether.collection.DependencyGraphTransformationContext;
+import org.sonatype.aether.collection.DependencyGraphTransformer;
+import org.sonatype.aether.collection.UnsolvableVersionConflictException;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.util.graph.transformer.ConflictIdSorter;
+import org.sonatype.aether.util.graph.transformer.TransformationContextKeys;
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionConstraint;
+
+/**
+ * A dependency graph transformer that resolves version conflicts using the
+ * nearest-wins strategy. For a given set of conflicting nodes, one node will be
+ * chosen as the winner and the other nodes are removed from the dependency
+ * graph.
+ * 
+ * @author Benjamin Bentmann
+ */
+public class NearestTransformer extends BaseTransformer {
+
+	static final class ConflictGroup {
+
+		final Map<DependencyNode, Position> candidates = new IdentityHashMap<DependencyNode, Position>(
+				32);
+
+		final Collection<VersionConstraint> constraints = new HashSet<VersionConstraint>();
+
+		final Object key;
+
+		Position position;
+
+		final Collection<Position> positions = new LinkedHashSet<Position>();
+
+		boolean pruned;
+
+		Version version;
+
+		public ConflictGroup(Object key) {
+			this.key = key;
+			this.position = new Position(null, Integer.MAX_VALUE);
+		}
+
+		@Override
+		public String toString() {
+			return key + " > " + version;
+		}
+
+	}
+
+	static final class Position {
+
+		final int depth;
+
+		final int hash;
+
+		final DependencyNode parent;
+
+		public Position(DependencyNode parent, int depth) {
+			this.parent = parent;
+			this.depth = depth;
+			hash = 31 * System.identityHashCode(parent) + depth;
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (this == obj) {
+				return true;
+			} else if (!(obj instanceof Position)) {
+				return false;
+			}
+			Position that = (Position) obj;
+			return this.parent == that.parent && this.depth == that.depth;
+		}
+
+		@Override
+		public int hashCode() {
+			return hash;
+		}
+
+		@Override
+		public String toString() {
+			return depth + " > " + parent;
+		}
+
+	}
+
+	private void backtrack(ConflictGroup group)
+			throws UnsolvableVersionConflictException {
+		group.version = null;
+
+		for (Iterator<Map.Entry<DependencyNode, Position>> it = group.candidates
+				.entrySet().iterator(); it.hasNext();) {
+			Map.Entry<DependencyNode, Position> entry = it.next();
+
+			Version version = entry.getKey().getVersion();
+			Position pos = entry.getValue();
+
+			if (!isAcceptable(group, version)) {
+				it.remove();
+			} else if (group.version == null
+					|| isNearer(pos, version, group.position, group.version)) {
+				group.version = version;
+				group.position = pos;
+			}
+		}
+
+		if (group.version == null) {
+			throw newFailure(group);
+		}
+
+	}
+
+	private boolean isAcceptable(ConflictGroup group, Version version) {
+		for (VersionConstraint constraint : group.constraints) {
+			if (!constraint.containsVersion(version)) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	private boolean isNearer(Position pos1, Version ver1, Position pos2,
+			Version ver2) {
+		if (pos1.depth < pos2.depth) {
+			return true;
+		} else if (pos1.depth == pos2.depth && pos1.parent == pos2.parent
+				&& ver1.compareTo(ver2) > 0) {
+			return true;
+		}
+		return false;
+	}
+
+	private UnsolvableVersionConflictException newFailure(ConflictGroup group) {
+
+		Collection<String> versions = new LinkedHashSet<String>();
+
+		for (VersionConstraint constraint : group.constraints) {
+			versions.add(constraint.toString());
+		}
+
+		return new UnsolvableVersionConflictException(group.key, versions);
+
+	}
+
+	private void pruneNonSelectedVersions(ConflictGroup group,
+			Map<DependencyNode, Object> conflictMap) {
+
+		for (Position pos : group.positions) {
+			for (Iterator<DependencyNode> iterator = pos.parent.getChildren()
+					.iterator(); iterator.hasNext();) {
+
+				DependencyNode node = iterator.next();
+
+				Object key = conflictMap.get(node);
+
+				if (group.key.equals(key)) {
+					if (!group.pruned && group.position.depth == pos.depth
+							&& group.version.equals(node.getVersion())) {
+						group.pruned = true;
+					} else {
+						iterator.remove();
+					}
+				}
+			}
+		}
+	}
+
+	private void selectVersion(//
+			DependencyNode node, //
+			DependencyNode root, //
+			int depth, //
+			Map<DependencyNode, Integer> depthMap, //
+			ConflictGroup group, //
+			Map<DependencyNode, Object> conflictMap //
+	) throws RepositoryException {
+
+		Integer smallestDepth = depthMap.get(node);
+
+		if (smallestDepth == null || smallestDepth.intValue() > depth) {
+			depthMap.put(node, Integer.valueOf(depth));
+		} else {
+			return;
+		}
+
+		Object key = conflictMap.get(node);
+
+		if (group.key.equals(key)) {
+
+			Position pos = new Position(root, depth);
+
+			if (root != null) {
+				group.positions.add(pos);
+			}
+
+			VersionConstraint constraint = node.getVersionConstraint();
+
+			boolean backtrack = false;
+			boolean hardConstraint = !constraint.getRanges().isEmpty();
+
+			if (hardConstraint) {
+				if (group.constraints.add(constraint)) {
+					if (group.version != null
+							&& !constraint.containsVersion(group.version)) {
+						backtrack = true;
+					}
+				}
+			}
+
+			if (isAcceptable(group, node.getVersion())) {
+				group.candidates.put(node, pos);
+
+				if (backtrack) {
+					backtrack(group);
+				} else if (group.version == null
+						|| isNearer(pos, node.getVersion(), group.position,
+								group.version)) {
+					group.version = node.getVersion();
+					group.position = pos;
+				}
+			} else {
+				if (backtrack) {
+					backtrack(group);
+				}
+				return;
+			}
+		}
+
+		depth++;
+
+		for (DependencyNode child : node.getChildren()) {
+			selectVersion(child, node, depth, depthMap, group, conflictMap);
+		}
+	}
+
+	public DependencyNode transformGraph(//
+			DependencyNode node, //
+			DependencyGraphTransformationContext context //
+	) throws RepositoryException {
+
+		List<Object> conflictList = conflictList(context);
+
+		Map<DependencyNode, Object> conflictMap = conflictMap(context);
+
+		Map<DependencyNode, Integer> depthMap = new IdentityHashMap<DependencyNode, Integer>(
+				conflictMap.size());
+
+		for (Object key : conflictList) {
+			ConflictGroup group = new ConflictGroup(key);
+			depthMap.clear();
+			selectVersion(node, null, 0, depthMap, group, conflictMap);
+			pruneNonSelectedVersions(group, conflictMap);
+		}
+
+		return node;
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/ap/xform/SemanticTransformer.java b/src/main/java/org/apache/karaf/tooling/ap/xform/SemanticTransformer.java
new file mode 100644
index 0000000..04e3750
--- /dev/null
+++ b/src/main/java/org/apache/karaf/tooling/ap/xform/SemanticTransformer.java
@@ -0,0 +1,218 @@
+package org.apache.karaf.tooling.ap.xform;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.karaf.tooling.ap.range.SemanticRangeFactory;
+import org.apache.karaf.tooling.ap.range.SemanticRangeList;
+import org.apache.karaf.tooling.ap.range.SemanticRange;
+import org.apache.karaf.tooling.ap.range.VersionType;
+import org.sonatype.aether.RepositoryException;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.collection.DependencyGraphTransformationContext;
+import org.sonatype.aether.collection.DependencyGraphTransformer;
+import org.sonatype.aether.graph.Dependency;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.util.graph.transformer.TransformationContextKeys;
+import org.sonatype.aether.version.Version;
+import org.sonatype.aether.version.VersionConstraint;
+
+/**
+ * @author Andrei Pozolotin
+ */
+public class SemanticTransformer extends BaseTransformer {
+
+	/** FIXME */
+	public static boolean isSnapshot(Version version) {
+		return version.toString().endsWith("-SNAPSHOT");
+	}
+
+	// private Map<DependencyNode, SemanticRange> rangeMap = new
+	// HashMap<DependencyNode, SemanticRange>();
+
+	/**
+	 * "Object" is a "conflict" or a wrapper for maven artifact.
+	 * <p>
+	 * equality == group:artifact:classifier:extensions
+	 * <p>
+	 * identity == unique instance
+	 * <p>
+	 * Conflict list and map are produced by previous transformers.
+	 */
+
+	/**
+	 * [conflict-key : range-list ]
+	 */
+	private Map<Object, SemanticRangeList> rangeMap = new HashMap<Object, SemanticRangeList>();
+
+	public SemanticRangeList list(Object key) {
+		SemanticRangeList list = rangeMap.get(key);
+		if (list == null) {
+			list = new SemanticRangeList();
+			rangeMap.put(key, list);
+		}
+		return list;
+	}
+
+	/**
+	 * Remove snapshots.
+	 */
+	public void listClean(DependencyNode root,
+			DependencyGraphTransformationContext context) {
+
+		Iterator<DependencyNode> iterator = root.getChildren().iterator();
+
+		while (iterator.hasNext()) {
+
+			DependencyNode node = iterator.next();
+
+			VersionType versionType = VersionType.form(node
+					.getVersionConstraint());
+
+			boolean isSnapshot = node.getDependency().getArtifact()
+					.isSnapshot();
+
+			switch (versionType) {
+			case RANGE:
+				break;
+			case VALUE:
+				break;
+			default:
+				throw new IllegalStateException("Wrong version type = "
+						+ versionType);
+			}
+
+			if (isSnapshot) {
+				iterator.remove();
+			}
+
+			listClean(node, context);
+		}
+
+	}
+
+	public void listCreate(DependencyNode root,
+			DependencyGraphTransformationContext context) {
+
+		Map<DependencyNode, Object> conflictMap = conflictMap(context);
+
+		for (DependencyNode node : root.getChildren()) {
+
+			Object key = conflictMap.get(node);
+
+			SemanticRange range = SemanticRangeFactory.from(node);
+
+			SemanticRangeList list = list(key);
+
+			list.addIfAbsent(range);
+
+			listCreate(node, context);
+
+		}
+
+	}
+
+	/**
+	 * Sort by lower bound.
+	 */
+	public void listSort(DependencyNode root,
+			DependencyGraphTransformationContext context) {
+
+		Map<DependencyNode, Object> conflictMap = conflictMap(context);
+
+		for (DependencyNode node : root.getChildren()) {
+
+			Object key = conflictMap.get(node);
+
+			SemanticRangeList list = list(key);
+
+		}
+
+	}
+
+	public DependencyNode transformGraph(DependencyNode root,
+			DependencyGraphTransformationContext context)
+			throws RepositoryException {
+
+		listClean(root, context);
+
+		listCreate(root, context);
+
+		listSort(root, context);
+
+		// for (Map.Entry<DependencyNode, Object> entry :
+		// conflictMap.entrySet()) {
+		// listCreate(entry.getKey(), context);
+		// }
+
+		log("rangeMap=" + rangeMap);
+
+		return root;
+
+	}
+
+	public DependencyNode transformGraphXXX(DependencyNode node,
+			DependencyGraphTransformationContext context)
+			throws RepositoryException {
+
+		log("node=" + node);
+
+		final List<Object> conflictList = conflictList(context);
+
+		for (Object key : conflictList) {
+			log("\t 1 key=" + key);
+		}
+
+		@SuppressWarnings("unchecked")
+		final Map<DependencyNode, Object> conflictMap = (Map<DependencyNode, Object>) context
+				.get(TransformationContextKeys.CONFLICT_IDS);
+
+		final Object key = conflictMap.get(node);
+		log("\t 2 key=" + key);
+		final Dependency dependency = node.getDependency();
+
+		for (Map.Entry<DependencyNode, Object> entry : conflictMap.entrySet()) {
+			log("\t 3 node=" + entry.getKey() + " key=" + entry.getValue());
+		}
+
+		final VersionConstraint constraint = node.getVersionConstraint();
+		log("\t 4 constraint=" + constraint);
+
+		final Artifact artifact = dependency.getArtifact();
+		log("\t 5 artifact=" + artifact);
+
+		Iterator<DependencyNode> iterator = node.getChildren().iterator();
+		while (iterator.hasNext()) {
+
+			DependencyNode item = iterator.next();
+			log("\t 6 item=" + item);
+
+			VersionConstraint itemConstraint = item.getVersionConstraint();
+			log("\t 7 constraint=" + itemConstraint);
+
+			Version itemVersion = item.getVersion();
+			log("\t 8 version=" + itemVersion);
+
+			switch (VersionType.form(itemConstraint)) {
+			case RANGE:
+				log("\t 9 ranges=" + itemConstraint.getRanges());
+				break;
+			case VALUE:
+				log("\t 10 version=" + itemVersion);
+				break;
+			}
+
+			if (item.getDependency().getArtifact().isSnapshot()) {
+				iterator.remove();
+			}
+		}
+
+		return node;
+
+	}
+
+}
diff --git a/src/main/java/org/apache/karaf/tooling/features/GenerateDescriptorMojo.java b/src/main/java/org/apache/karaf/tooling/features/GenerateDescriptorMojo.java
index 65d4aa8..4b4a995 100644
--- a/src/main/java/org/apache/karaf/tooling/features/GenerateDescriptorMojo.java
+++ b/src/main/java/org/apache/karaf/tooling/features/GenerateDescriptorMojo.java
@@ -103,7 +103,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      *
      * @parameter default-value="${project.build.directory}/feature/feature.xml"
      */
-    private File outputFile;
+    protected File outputFile;
 
     /**
      * The resolver to use for the feature.  Normally null or "OBR" or "(OBR)"
@@ -117,14 +117,14 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      *
      * @parameter default-value="xml"
      */
-    private String attachmentArtifactType = "xml";
+    protected String attachmentArtifactType = "xml";
 
     /**
      * (wrapper) The artifact classifier for attaching the generated file to the project
      *
      * @parameter default-value="features"
      */
-    private String attachmentArtifactClassifier = "features";
+    protected String attachmentArtifactClassifier = "features";
 
     /**
      * Specifies whether features dependencies of this project will be included inline of the the
@@ -169,7 +169,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      *
      * @parameter default-value="true"
      */
-    private boolean includeTransitiveDependency;
+    protected boolean includeTransitiveDependency;
 
     /**
      * The standard behavior is to add dependencies as <code>&lt;bundle&gt;</code> elements to a <code>&lt;feature&gt;</code>
@@ -208,7 +208,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      * @required
      * @readonly
      */
-    private RepositorySystem repoSystem;
+    protected RepositorySystem repoSystem;
 
     /**
      * The current repository/network configuration of Maven.
@@ -217,7 +217,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      * @required
      * @readonly
      */
-    private RepositorySystemSession repoSession;
+    protected RepositorySystemSession repoSession;
 
     /**
      * The project's remote repositories to use for the resolution of project dependencies.
@@ -225,7 +225,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      * @parameter default-value="${project.remoteProjectRepositories}"
      * @readonly
      */
-    private List<RemoteRepository> projectRepos;
+    protected List<RemoteRepository> projectRepos;
 
     /**
      * The project's remote repositories to use for the resolution of plugins and their dependencies.
@@ -234,7 +234,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
      * @required
      * @readonly
      */
-    private List<RemoteRepository> pluginRepos;
+    protected List<RemoteRepository> pluginRepos;
 
     /**
      * @component role="org.apache.maven.shared.filtering.MavenResourcesFiltering" role-hint="default"
@@ -266,12 +266,16 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
     //maven log
     private Log log;
 
+    protected void prepare() throws Exception {
+        DependencyHelper dependencyHelper = new DependencyHelper(pluginRepos, projectRepos, repoSession, repoSystem);
+        dependencyHelper.getDependencies(project, includeTransitiveDependency);
+        this.localDependencies = dependencyHelper.getLocalDependencies();
+        this.treeListing = dependencyHelper.getTreeListing();
+    }
+    
     public void execute() throws MojoExecutionException, MojoFailureException {
         try {
-            DependencyHelper dependencyHelper = new DependencyHelper(pluginRepos, projectRepos, repoSession, repoSystem);
-            dependencyHelper.getDependencies(project, includeTransitiveDependency);
-            this.localDependencies = dependencyHelper.getLocalDependencies();
-            this.treeListing = dependencyHelper.getTreeListing();
+        	prepare();
             File dir = outputFile.getParentFile();
             if (dir.isDirectory() || dir.mkdirs()) {
                 PrintStream out = new PrintStream(new FileOutputStream(outputFile));
@@ -295,7 +299,7 @@ public class GenerateDescriptorMojo extends AbstractLogEnabled implements Mojo {
     /*
      * Write all project dependencies as feature
      */
-    private void writeFeatures(PrintStream out) throws ArtifactResolutionException, ArtifactNotFoundException,
+    protected void writeFeatures(PrintStream out) throws ArtifactResolutionException, ArtifactNotFoundException,
             IOException, JAXBException, SAXException, ParserConfigurationException, XMLStreamException, MojoExecutionException {
         getLogger().info("Generating feature descriptor file " + outputFile.getAbsolutePath());
         //read in an existing feature.xml
diff --git a/src/main/java/org/apache/karaf/tooling/features/MavenUtil.java b/src/main/java/org/apache/karaf/tooling/features/MavenUtil.java
index cb804e8..c9b2c07 100644
--- a/src/main/java/org/apache/karaf/tooling/features/MavenUtil.java
+++ b/src/main/java/org/apache/karaf/tooling/features/MavenUtil.java
@@ -36,6 +36,7 @@ import org.apache.maven.artifact.repository.metadata.Snapshot;
 import org.apache.maven.artifact.repository.metadata.SnapshotVersion;
 import org.apache.maven.artifact.repository.metadata.Versioning;
 import org.apache.maven.artifact.repository.metadata.io.xpp3.MetadataXpp3Writer;
+import org.apache.maven.project.MavenProject;
 import org.sonatype.aether.util.artifact.DefaultArtifact;
 
 /**
@@ -218,5 +219,9 @@ public class MavenUtil {
         Writer writer = new FileWriter(target);
         metadataWriter.write(writer, metadata);
     }
+    
+    public static Artifact toAetherArtifact(MavenProject project){
+    	return null;
+    }
 
 }
diff --git a/src/test/java/org/apache/karaf/tooling/ap/DependencyHelperTest.java b/src/test/java/org/apache/karaf/tooling/ap/DependencyHelperTest.java
new file mode 100644
index 0000000..50317f2
--- /dev/null
+++ b/src/test/java/org/apache/karaf/tooling/ap/DependencyHelperTest.java
@@ -0,0 +1,165 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.karaf.tooling.ap;
+
+import static org.junit.Assert.*;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+
+import javax.xml.bind.JAXBException;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLStreamException;
+
+import org.apache.karaf.features.FeaturesNamespaces;
+import org.apache.karaf.features.internal.model.Features;
+import org.apache.karaf.features.internal.model.Feature;
+import org.apache.karaf.features.internal.model.JaxbUtil;
+import org.apache.karaf.tooling.features.DependencyHelper;
+import org.apache.maven.project.MavenProject;
+import org.apache.maven.repository.internal.MavenRepositorySystemSession;
+import org.junit.Test;
+import org.xml.sax.SAXException;
+
+import org.codehaus.plexus.DefaultPlexusContainer;
+import org.sonatype.aether.RepositorySystem;
+import org.sonatype.aether.RepositorySystemSession;
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.collection.CollectRequest;
+import org.sonatype.aether.collection.CollectResult;
+import org.sonatype.aether.collection.DependencyGraphTransformer;
+import org.sonatype.aether.graph.Dependency;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.graph.Exclusion;
+import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.resolution.DependencyRequest;
+import org.sonatype.aether.resolution.DependencyResult;
+import org.sonatype.aether.util.DefaultRepositorySystemSession;
+import org.sonatype.aether.util.artifact.DefaultArtifact;
+import org.sonatype.aether.util.graph.PreorderNodeListGenerator;
+import org.sonatype.aether.util.graph.selector.AndDependencySelector;
+import org.sonatype.aether.util.graph.selector.ExclusionDependencySelector;
+import org.sonatype.aether.util.graph.selector.OptionalDependencySelector;
+import org.sonatype.aether.util.graph.selector.ScopeDependencySelector;
+import org.sonatype.aether.util.graph.transformer.ChainedDependencyGraphTransformer;
+import org.sonatype.aether.util.graph.transformer.ConflictMarker;
+import org.sonatype.aether.util.graph.transformer.JavaDependencyContextRefiner;
+import org.sonatype.aether.util.graph.transformer.JavaEffectiveScopeCalculator;
+
+public class DependencyHelperTest {
+
+	DependencyHelper newHelper() throws Exception {
+
+		final List<RemoteRepository> remoteList = new ArrayList<RemoteRepository>();
+		remoteList.add(UnitHelp.newRepoRemote());
+
+		final List<RemoteRepository> pluginRepos = remoteList;
+		final List<RemoteRepository> projectRepos = remoteList;
+		final RepositorySystem system = UnitHelp.newSystem();
+		final RepositorySystemSession session = UnitHelp.newSession(system);
+
+		final DependencyHelper helper = new DependencyHelper(pluginRepos,
+				projectRepos, session, system);
+
+		return helper;
+
+	}
+
+	@Test
+	public void dependency() throws Exception {
+
+		final String uri = "com.carrotgarden.osgi:carrot-osgi-anno-scr-make:pom:1.1.3";
+
+		final DependencyHelper helper = newHelper();
+
+		final MavenProject project = UnitHelp.newProject(uri);
+
+		Collection<String> included = null;
+		Collection<String> excluded = null;
+
+		helper.getDependencies(project, true);
+
+		final String report = helper.getTreeListing();
+
+		System.out.println("\n" + report);
+
+	}
+
+	public static void main(String[] args) throws Exception {
+
+		final String uri = "com.carrotgarden.osgi:carrot-osgi-anno-scr-make:jar:1.1.3";
+
+		final Artifact artifact = new DefaultArtifact(uri);
+
+		Dependency dependency = new Dependency(artifact, "compile");
+
+		CollectRequest collectRequest = new CollectRequest(dependency, null);
+
+		RepositorySystem system = UnitHelp.newSystem();
+
+		MavenRepositorySystemSession session = UnitHelp.newSession(system);
+
+		session.setOffline(true);
+
+		Collection<String> scopeIncluded = new ArrayList<String>();
+		Collection<String> scopeExcluded = new ArrayList<String>();
+
+		scopeIncluded.add("provided");
+
+		scopeExcluded.add("test");
+
+		session.setDependencySelector( //
+		new AndDependencySelector(//
+				new OptionalDependencySelector(), //
+				new ScopeDependencySelector(scopeIncluded, scopeExcluded), //
+				new ExclusionDependencySelector()) //
+		);
+
+		CollectResult collectResult = system.collectDependencies(session,
+				collectRequest);
+
+		DependencyNode collectNode = collectResult.getRoot();
+
+		final DependencyRequest dependencyRequest = new DependencyRequest(
+				collectNode, null);
+
+		final DependencyResult result = system.resolveDependencies(session,
+				dependencyRequest);
+
+		final DependencyNode resolveNode = result.getRoot();
+
+		final PreorderNodeListGenerator generator = new PreorderNodeListGenerator();
+
+		resolveNode.accept(generator);
+
+		List<Artifact> list = generator.getArtifacts(true);
+
+		for (Artifact item : list) {
+			System.out.println("item = " + item );
+		}
+
+	}
+
+}
diff --git a/src/test/java/org/apache/karaf/tooling/ap/GenerateSemanticMojoTest.java b/src/test/java/org/apache/karaf/tooling/ap/GenerateSemanticMojoTest.java
new file mode 100644
index 0000000..707e9d6
--- /dev/null
+++ b/src/test/java/org/apache/karaf/tooling/ap/GenerateSemanticMojoTest.java
@@ -0,0 +1,170 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.karaf.tooling.ap;
+
+import static org.junit.Assert.*;
+
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.maven.project.MavenProject;
+import org.codehaus.plexus.logging.Logger;
+import org.junit.Test;
+import org.sonatype.aether.RepositorySystem;
+import org.sonatype.aether.RepositorySystemSession;
+import org.sonatype.aether.artifact.Artifact;
+
+public class GenerateSemanticMojoTest {
+
+	@Test
+	public void dependency1() throws Exception {
+
+		Logger logger = UnitHelp.logger();
+
+		logger.info("===");
+
+		String uri = "com.carrotgarden.osgi:carrot-osgi-anno-scr-make:pom:1.1.3";
+
+		MavenProject project = UnitHelp.newProject(uri);
+
+		Set<String> scopeIncluded;
+		{
+			scopeIncluded = new HashSet<String>();
+			scopeIncluded.add("compile");
+			scopeIncluded.add("runtime");
+		}
+
+		Set<String> scopeExcluded;
+		{
+			scopeExcluded = new HashSet<String>();
+			scopeExcluded.add("provided");
+			scopeExcluded.add("system");
+			scopeExcluded.add("test");
+		}
+
+		RepositorySystem system = UnitHelp.newSystem();
+		RepositorySystemSession session = UnitHelp.newSession(system);
+
+		MojoContext context = new MojoContext(logger, project, scopeIncluded,
+				scopeExcluded, system, session, UnitHelp.newRepoRemoteList());
+
+		Map<Artifact, String> dependencyMap = GenerateSemanticMojo
+				.prepare(context);
+
+		for (Map.Entry<Artifact, String> entry : dependencyMap.entrySet()) {
+			Artifact artifact = entry.getKey();
+			String scope = entry.getValue();
+			logger.info(artifact + " @ " + scope);
+		}
+
+		assertEquals(1, dependencyMap.size());
+
+	}
+
+	@Test
+	public void dependency2() throws Exception {
+
+		Logger logger = UnitHelp.logger();
+
+		logger.info("===");
+
+		String uri = "com.carrotgarden.osgi:carrot-osgi-anno-scr-make:pom:1.1.3";
+
+		MavenProject project = UnitHelp.newProject(uri);
+
+		Set<String> scopeIncluded;
+		{
+			scopeIncluded = new HashSet<String>();
+			scopeIncluded.add("provided");
+			scopeIncluded.add("runtime");
+		}
+
+		Set<String> scopeExcluded;
+		{
+			scopeExcluded = new HashSet<String>();
+			scopeExcluded.add("compile");
+			scopeExcluded.add("system");
+			scopeExcluded.add("test");
+		}
+
+		RepositorySystem system = UnitHelp.newSystem();
+		RepositorySystemSession session = UnitHelp.newSession(system);
+
+		MojoContext context = new MojoContext(logger, project, scopeIncluded,
+				scopeExcluded, system, session, UnitHelp.newRepoRemoteList());
+
+		Map<Artifact, String> dependencyMap = GenerateSemanticMojo
+				.prepare(context);
+
+		for (Map.Entry<Artifact, String> entry : dependencyMap.entrySet()) {
+			Artifact artifact = entry.getKey();
+			String scope = entry.getValue();
+			logger.info(artifact + " @ " + scope);
+		}
+
+		assertEquals(5, dependencyMap.size());
+
+	}
+
+	@Test
+	public void dependency3() throws Exception {
+
+		Logger logger = UnitHelp.logger();
+
+		logger.info("===");
+
+		String uri = "com.barchart.version.tester:tester-one-zoo:pom:1.0.7";
+
+		MavenProject project = UnitHelp.newProject(uri);
+
+		Set<String> scopeIncluded;
+		{
+			scopeIncluded = new HashSet<String>();
+			scopeIncluded.add("compile");
+		}
+
+		Set<String> scopeExcluded;
+		{
+			scopeExcluded = new HashSet<String>();
+			scopeExcluded.add("runtime");
+			scopeExcluded.add("provided");
+			scopeExcluded.add("system");
+			scopeExcluded.add("test");
+		}
+
+		RepositorySystem system = UnitHelp.newSystem();
+		RepositorySystemSession session = UnitHelp.newSession(system);
+
+		MojoContext context = new MojoContext(logger, project, scopeIncluded,
+				scopeExcluded, system, session, UnitHelp.newRepoRemoteList());
+
+		Map<Artifact, String> dependencyMap = GenerateSemanticMojo
+				.prepare(context);
+
+		for (Map.Entry<Artifact, String> entry : dependencyMap.entrySet()) {
+			Artifact artifact = entry.getKey();
+			String scope = entry.getValue();
+			logger.info(artifact + " @ " + scope);
+		}
+
+	}
+
+}
diff --git a/src/test/java/org/apache/karaf/tooling/ap/KarafDependencySelector.java b/src/test/java/org/apache/karaf/tooling/ap/KarafDependencySelector.java
new file mode 100644
index 0000000..66a9b1a
--- /dev/null
+++ b/src/test/java/org/apache/karaf/tooling/ap/KarafDependencySelector.java
@@ -0,0 +1,44 @@
+/**
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.karaf.tooling.ap;
+
+import java.util.Collection;
+
+import org.sonatype.aether.collection.DependencyCollectionContext;
+import org.sonatype.aether.collection.DependencySelector;
+import org.sonatype.aether.graph.Dependency;
+
+public class KarafDependencySelector implements DependencySelector {
+
+	public KarafDependencySelector(Collection<String> included,
+			Collection<String> excluded) {
+	}
+
+	public boolean selectDependency(Dependency dependency) {
+		System.out.println("dependency : "+ dependency);
+		return true;
+	}
+
+	@Override
+	public DependencySelector deriveChildSelector(
+			DependencyCollectionContext context) {
+		System.out.println("context    : "+ context);
+		return this;
+	}
+
+}
diff --git a/src/test/java/org/apache/karaf/tooling/ap/SimpleWagonProvider.java b/src/test/java/org/apache/karaf/tooling/ap/SimpleWagonProvider.java
new file mode 100644
index 0000000..3958a6f
--- /dev/null
+++ b/src/test/java/org/apache/karaf/tooling/ap/SimpleWagonProvider.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.karaf.tooling.ap;
+
+import org.apache.maven.wagon.Wagon;
+import org.apache.maven.wagon.providers.http.LightweightHttpWagon;
+import org.apache.maven.wagon.providers.http.LightweightHttpsWagon;
+import org.sonatype.aether.connector.wagon.WagonProvider;
+
+public class SimpleWagonProvider implements WagonProvider {
+
+	public Wagon lookup(String roleHint) throws Exception {
+
+		if (roleHint.startsWith("file")) {
+			return null;
+		}
+
+		if (roleHint.startsWith("http")) {
+			return new LightweightHttpWagon();
+		}
+
+		if (roleHint.startsWith("https")) {
+			return new LightweightHttpsWagon();
+		}
+
+		return null;
+
+	}
+
+	public void release(Wagon wagon) {
+	}
+
+}
diff --git a/src/test/java/org/apache/karaf/tooling/ap/UnitHelp.java b/src/test/java/org/apache/karaf/tooling/ap/UnitHelp.java
new file mode 100644
index 0000000..ad0fa01
--- /dev/null
+++ b/src/test/java/org/apache/karaf/tooling/ap/UnitHelp.java
@@ -0,0 +1,282 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *  http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.karaf.tooling.ap;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import org.ops4j.pax.url.mvn.internal.ManualWagonProvider;
+import org.sonatype.aether.RepositorySystem;
+import org.sonatype.aether.RepositorySystemSession;
+
+import org.sonatype.aether.artifact.Artifact;
+import org.sonatype.aether.collection.CollectRequest;
+import org.sonatype.aether.connector.wagon.WagonProvider;
+import org.sonatype.aether.connector.wagon.WagonRepositoryConnectorFactory;
+import org.sonatype.aether.graph.Dependency;
+import org.sonatype.aether.graph.DependencyFilter;
+import org.sonatype.aether.graph.DependencyNode;
+import org.sonatype.aether.impl.ArtifactDescriptorReader;
+import org.sonatype.aether.impl.VersionRangeResolver;
+import org.sonatype.aether.impl.VersionResolver;
+import org.sonatype.aether.impl.internal.DefaultRepositorySystem;
+import org.sonatype.aether.impl.internal.DefaultServiceLocator;
+import org.sonatype.aether.repository.LocalRepository;
+import org.sonatype.aether.repository.RemoteRepository;
+import org.sonatype.aether.resolution.ArtifactRequest;
+import org.sonatype.aether.resolution.ArtifactResolutionException;
+import org.sonatype.aether.resolution.ArtifactResult;
+import org.sonatype.aether.resolution.DependencyRequest;
+import org.sonatype.aether.resolution.DependencyResult;
+import org.sonatype.aether.spi.connector.RepositoryConnectorFactory;
+import org.sonatype.aether.util.artifact.DefaultArtifact;
+import org.sonatype.aether.util.filter.ScopeDependencyFilter;
+import org.sonatype.aether.util.graph.PreorderNodeListGenerator;
+import org.apache.maven.RepositoryUtils;
+import org.apache.maven.model.Model;
+import org.apache.maven.model.io.DefaultModelReader;
+import org.apache.maven.model.io.ModelReader;
+import org.apache.maven.project.MavenProject;
+import org.apache.maven.repository.internal.DefaultArtifactDescriptorReader;
+import org.apache.maven.repository.internal.DefaultVersionRangeResolver;
+import org.apache.maven.repository.internal.DefaultVersionResolver;
+import org.apache.maven.repository.internal.MavenRepositorySystemSession;
+import org.apache.maven.wagon.Wagon;
+import org.apache.maven.wagon.providers.http.LightweightHttpWagon;
+import org.codehaus.plexus.logging.Logger;
+import org.codehaus.plexus.logging.console.ConsoleLogger;
+
+public class UnitHelp {
+
+	private static volatile Logger logger;
+
+	public static final String URL_CENTRAL = "http://repo1.maven.org/maven2/";
+
+	public static final String URL_SONATYPE = "http://oss.sonatype.org/content/groups/public/";
+
+	public static Logger logger() {
+		if (logger == null) {
+			logger = new ConsoleLogger();
+		}
+		return logger;
+	}
+
+	/**
+	 * Verify operation manually.
+	 */
+	public static void main(String[] args) throws Exception {
+
+		final Logger log = logger();
+
+		final RepositorySystem system = newSystem();
+
+		final RepositorySystemSession session = newSession(system);
+
+		// String uri = "jmock:jmock:pom:1.1.0";
+		String uri = "org.apache.maven:maven-profile:2.2.1";
+
+		final Artifact artifact = new DefaultArtifact(uri);
+
+		final Dependency dependency = new Dependency(artifact, "compile");
+
+		final RemoteRepository central = newRepoRemote();
+
+		final CollectRequest collectRequest = new CollectRequest();
+		collectRequest.setRoot(dependency);
+		collectRequest.addRepository(central);
+
+		final DependencyNode collectNode = system.collectDependencies(session,
+				collectRequest).getRoot();
+
+		final List<String> include = new ArrayList<String>();
+		final List<String> exclude = new ArrayList<String>();
+
+		final DependencyFilter filter = new ScopeDependencyFilter(include,
+				exclude);
+
+		final DependencyRequest dependencyRequest = new DependencyRequest(
+				collectNode, filter);
+
+		final DependencyResult result = system.resolveDependencies(session,
+				dependencyRequest);
+
+		final DependencyNode resolveNode = result.getRoot();
+
+		final PreorderNodeListGenerator generator = new PreorderNodeListGenerator();
+
+		resolveNode.accept(generator);
+
+		final String[] pathArray = generator.getClassPath().split(
+				File.pathSeparator);
+
+		for (String path : pathArray) {
+			log.info("path = " + path);
+		}
+
+		//
+
+		final MavenProject project = newProject("org.apache.maven:maven-model:pom:3.0");
+
+		log.info("project = " + project);
+
+	}
+
+	/**
+	 * Resolve maven URI into maven artifact.
+	 */
+	public static Artifact newArtifact(String mavenURI) throws Exception {
+
+		final RepositorySystem system = newSystem();
+		final RepositorySystemSession session = newSession(system);
+		final RemoteRepository central = newRepoRemote();
+
+		final ArtifactRequest request = new ArtifactRequest();
+		request.setArtifact(new DefaultArtifact(mavenURI));
+		request.addRepository(central);
+
+		final ArtifactResult result = system.resolveArtifact(session, request);
+
+		final Artifact artifact = result.getArtifact();
+
+		return artifact;
+
+	}
+
+	/**
+	 * Resolve maven URI into maven project.
+	 * <p>
+	 * Provides only model and artifact.
+	 */
+	public static MavenProject newProject(String mavenURI) throws Exception {
+
+		final Artifact artifact = newArtifact(mavenURI);
+
+		final File input = artifact.getFile();
+
+		final ModelReader reader = new DefaultModelReader();
+
+		final Model model = reader.read(input, null);
+
+		final MavenProject project = new MavenProject(model);
+
+		project.setArtifact(RepositoryUtils.toArtifact(artifact));
+
+		return project;
+
+	}
+
+	/**
+	 * Local user repository.
+	 */
+	public static File newRepoFolder() throws Exception {
+		final File home = new File(System.getProperty("user.home"));
+		final File repo = new File(home, ".m2/repository");
+		return repo;
+	}
+
+	/**
+	 * Local user repository.
+	 */
+	public static LocalRepository newRepoLocal() throws Exception {
+		return new LocalRepository(newWorkFolder());
+	}
+
+	/**
+	 * Remote central repository.
+	 */
+	public static RemoteRepository newRepoRemote() throws Exception {
+		final RemoteRepository central = new RemoteRepository("central",
+				"default", URL_CENTRAL);
+		return central;
+	}
+
+	/**
+	 * Remote central repository as list.
+	 */
+	public static List<RemoteRepository> newRepoRemoteList() throws Exception {
+		return Collections.singletonList(newRepoRemote());
+	}
+
+	/**
+	 * Default repository session.
+	 */
+	public static RepositorySystemSession newSession() throws Exception {
+		return newSession(newSystem());
+	}
+
+	/**
+	 * Default repository session.
+	 */
+	public static MavenRepositorySystemSession newSession(
+			RepositorySystem system) throws Exception {
+
+		final LocalRepository localRepo = newRepoLocal();
+
+		final MavenRepositorySystemSession session = new MavenRepositorySystemSession();
+
+		session.setLocalRepositoryManager(system
+				.newLocalRepositoryManager(localRepo));
+
+		return session;
+
+	}
+
+	/**
+	 * Default repository system.
+	 */
+	public static RepositorySystem newSystem() throws Exception {
+
+		DefaultServiceLocator locator = new DefaultServiceLocator();
+
+		locator.addService(VersionResolver.class, DefaultVersionResolver.class);
+
+		locator.addService(VersionRangeResolver.class,
+				DefaultVersionRangeResolver.class);
+
+		locator.addService(ArtifactDescriptorReader.class,
+				DefaultArtifactDescriptorReader.class);
+
+		locator.addService(WagonProvider.class, SimpleWagonProvider.class);
+
+		locator.addService(RepositoryConnectorFactory.class,
+				WagonRepositoryConnectorFactory.class);
+
+		return locator.getService(RepositorySystem.class);
+
+	}
+
+	/**
+	 * Local repository.
+	 */
+	public static File newWorkFolder() throws Exception {
+		final File work = new File(System.getProperty("user.dir"));
+		final File target = new File(work, "target");
+		// final File repo = new File(target, "repo-" +
+		// System.currentTimeMillis());
+		final File repo = new File(target, "repo-local");
+		repo.mkdirs();
+		repo.deleteOnExit();
+		return repo;
+	}
+
+}
